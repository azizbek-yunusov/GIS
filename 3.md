# ðŸ—ºï¸ Map Technologies - Murakkab Savollar Davomi

## MURAKKAB SAVOLLAR - Davomi

**2. Point-in-polygon operatsiyasini frontendda optimallashtirib qanday qilish?**

**Muammo:**
- 10,000 polygon, 5,000 point
- Har bir point uchun har bir polygonni tekshirish = 50 million operatsiya
- Har bir check ~0.1ms = 5000 sekund (83 minut!) âŒ

**Yechim: Spatial Indexing + Ray Casting Algorithm**

```javascript
// 1. Bounding Box Pre-filter
class PolygonIndex {
  constructor(polygons) {
    this.polygons = polygons;
    this.index = this.buildRTree();
  }
  
  buildRTree() {
    // R-Tree: Spatial index structure
    const tree = new RBush();
    
    this.polygons.forEach((polygon, id) => {
      const bbox = this.getBoundingBox(polygon);
      tree.insert({
        minX: bbox.minLng,
        minY: bbox.minLat,
        maxX: bbox.maxLng,
        maxY: bbox.maxLat,
        polygon: polygon,
        id: id
      });
    });
    
    return tree;
  }
  
  getBoundingBox(polygon) {
    const coords = polygon.geometry.coordinates[0];
    return {
      minLng: Math.min(...coords.map(c => c[0])),
      maxLng: Math.max(...coords.map(c => c[0])),
      minLat: Math.min(...coords.map(c => c[1])),
      maxLat: Math.max(...coords.map(c => c[1]))
    };
  }
  
  // Fast lookup
  findPolygonsForPoint(lng, lat) {
    // 1. R-Tree bilan kandidatlarni topish (juda tez)
    const candidates = this.index.search({
      minX: lng,
      minY: lat,
      maxX: lng,
      maxY: lat
    });
    
    // 2. Faqat kandidatlar uchun aniq tekshirish
    return candidates.filter(candidate => 
      this.pointInPolygon([lng, lat], candidate.polygon)
    );
  }
  
  // Ray Casting Algorithm (optimized)
  pointInPolygon(point, polygon) {
    const [x, y] = point;
    const coords = polygon.geometry.coordinates[0];
    let inside = false;
    
    for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {
      const xi = coords[i][0], yi = coords[i][1];
      const xj = coords[j][0], yj = coords[j][1];
      
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      
      if (intersect) inside = !inside;
    }
    
    return inside;
  }
}

// Ishlatish
const polygonIndex = new PolygonIndex(allPolygons);

// Batch processing
function batchCheckPoints(points) {
  const results = [];
  
  points.forEach(point => {
    const matchedPolygons = polygonIndex.findPolygonsForPoint(
      point.lng, 
      point.lat
    );
    
    results.push({
      point: point,
      polygons: matchedPolygons
    });
  });
  
  return results;
}

// Web Worker uchun (UI block qilmaslik)
// worker.js
self.onmessage = (e) => {
  const { points, polygons } = e.data;
  const index = new PolygonIndex(polygons);
  
  const results = points.map(point => ({
    id: point.id,
    containingPolygons: index.findPolygonsForPoint(point.lng, point.lat)
  }));
  
  self.postMessage(results);
};

// main.js
const worker = new Worker('worker.js');

worker.postMessage({
  points: allPoints,
  polygons: allPolygons
});

worker.onmessage = (e) => {
  const results = e.data;
  updateMap(results);
};
```

**Turf.js bilan (oddiyroq lekin sekinroq):**
```javascript
import * as turf from '@turf/turf';

// Simple uchun
const point = turf.point([69.24, 41.29]);
const polygon = turf.polygon([[[69, 41], [70, 41], [70, 42], [69, 42], [69, 41]]]);

const isInside = turf.booleanPointInPolygon(point, polygon);

// Batch uchun
function findPolygonForPoints(points, polygons) {
  const results = new Map();
  
  points.forEach(point => {
    const pt = turf.point([point.lng, point.lat]);
    
    for (const polygon of polygons) {
      if (turf.booleanPointInPolygon(pt, polygon)) {
        results.set(point.id, polygon.properties.name);
        break; // Birinchi topilganda to'xtatish
      }
    }
  });
  
  return results;
}
```

**Performance comparison:**
```
Naive approach: 50M checks = 83 minut
R-Tree + Ray Casting: ~500ms âœ…
Turf.js: ~2-3 sekund
Web Worker: Non-blocking, 500ms âœ…âœ…
```

---

**3. 3D buildings yoki terrain qo'shishda performance qanday nazorat qilinadi?**

```javascript
// 1. LOD (Level of Detail) System
class Building3DManager {
  constructor(map) {
    this.map = map;
    this.lodLevels = {
      low: { zoom: [0, 14], detail: 'simple' },
      medium: { zoom: [14, 16], detail: 'normal' },
      high: { zoom: [16, 22], detail: 'full' }
    };
  }
  
  getCurrentLOD() {
    const zoom = this.map.getZoom();
    
    if (zoom < 14) return 'low';
    if (zoom < 16) return 'medium';
    return 'high';
  }
  
  add3DBuildings() {
    const lod = this.getCurrentLOD();
    
    // Low LOD: Faqat ranglar
    if (lod === 'low') {
      this.map.addLayer({
        id: '3d-buildings',
        type: 'fill',
        source: 'composite',
        'source-layer': 'building',
        paint: {
          'fill-color': '#aaa',
          'fill-opacity': 0.6
        }
      });
      return;
    }
    
    // Medium/High LOD: Extrusion
    this.map.addLayer({
      id: '3d-buildings',
      type: 'fill-extrusion',
      source: 'composite',
      'source-layer': 'building',
      filter: ['==', 'extrude', 'true'],
      paint: {
        'fill-extrusion-color': '#aaa',
        
        // Height based on LOD
        'fill-extrusion-height': lod === 'high' 
          ? ['get', 'height']
          : ['*', ['get', 'height'], 0.5],
        
        'fill-extrusion-base': lod === 'high'
          ? ['get', 'min_height']
          : 0,
        
        'fill-extrusion-opacity': 0.8
      }
    });
  }
  
  // Viewport culling
  updateVisibleBuildings() {
    const bounds = this.map.getBounds();
    const zoom = this.map.getZoom();
    
    // Faqat viewport ichidagi binolarni render qilish
    this.map.setFilter('3d-buildings', [
      'all',
      ['==', 'extrude', 'true'],
      zoom < 16 ? ['>', 'height', 50] : null // Kichik zoom'da faqat baland binolar
    ].filter(Boolean));
  }
}

// 2. Terrain Performance Control
const terrainConfig = {
  source: 'mapbox-dem',
  exaggeration: 1.5,
  
  // Performance optimization
  get exaggeration() {
    const zoom = map.getZoom();
    if (zoom < 10) return 0; // Terrain off
    if (zoom < 12) return 0.5; // Low detail
    return 1.5; // Full detail
  }
};

map.addSource('mapbox-dem', {
  type: 'raster-dem',
  url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
  tileSize: 512,
  maxzoom: 14
});

map.setTerrain({
  source: 'mapbox-dem',
  exaggeration: terrainConfig.exaggeration
});

// 3. Performance Monitoring
class PerformanceMonitor {
  constructor(map) {
    this.map = map;
    this.fps = 60;
    this.frameCount = 0;
    this.lastTime = performance.now();
  }
  
  start() {
    this.monitor();
  }
  
  monitor() {
    this.frameCount++;
    const now = performance.now();
    
    if (now - this.lastTime >= 1000) {
      this.fps = Math.round(this.frameCount * 1000 / (now - this.lastTime));
      
      // Auto-adjust quality
      if (this.fps < 30) {
        this.degradeQuality();
      } else if (this.fps > 50) {
        this.improveQuality();
      }
      
      this.frameCount = 0;
      this.lastTime = now;
    }
    
    requestAnimationFrame(() => this.monitor());
  }
  
  degradeQuality() {
    console.warn('Low FPS detected, reducing quality...');
    
    // Terrain exaggeration kamaytirish
    this.map.setTerrain({
      source: 'mapbox-dem',
      exaggeration: 0.5
    });
    
    // 3D buildings oddiylashtirish
    this.map.setPaintProperty('3d-buildings', 'fill-extrusion-opacity', 0.4);
  }
  
  improveQuality() {
    // Quality oshirish
    this.map.setTerrain({
      source: 'mapbox-dem',
      exaggeration: 1.5
    });
  }
}

// 4. Lazy Loading Strategy
class Lazy3DLoader {
  constructor(map) {
    this.map = map;
    this.loaded = new Set();
  }
  
  loadBuildingsInViewport() {
    const bounds = this.map.getBounds();
    const tileKey = this.getTileKey(bounds);
    
    if (this.loaded.has(tileKey)) return;
    
    // Load buildings for this tile
    fetch(`/api/buildings?bbox=${bounds.toBBoxString()}`)
      .then(res => res.json())
      .then(data => {
        this.addBuildingsToMap(data);
        this.loaded.add(tileKey);
      });
  }
  
  getTileKey(bounds) {
    const zoom = Math.floor(this.map.getZoom());
    return `${zoom}/${bounds.getCenter().lat}/${bounds.getCenter().lng}`;
  }
}

// 5. Memory Management
class MemoryManager {
  constructor(map) {
    this.map = map;
    this.maxMemory = 512; // MB
  }
  
  checkMemory() {
    if (performance.memory) {
      const usedMB = performance.memory.usedJSHeapSize / 1048576;
      
      if (usedMB > this.maxMemory) {
        this.clearUnusedResources();
      }
    }
  }
  
  clearUnusedResources() {
    // Remove far buildings
    const center = this.map.getCenter();
    const zoom = this.map.getZoom();
    
    this.map.setFilter('3d-buildings', [
      'all',
      ['==', 'extrude', 'true'],
      ['<', 
        ['distance', ['get', 'coordinates'], [center.lng, center.lat]],
        this.getMaxDistance(zoom)
      ]
    ]);
  }
  
  getMaxDistance(zoom) {
    return zoom < 14 ? 1000 : zoom < 16 ? 500 : 200;
  }
}

// Ishlatish
const buildingManager = new Building3DManager(map);
const perfMonitor = new PerformanceMonitor(map);
const memoryManager = new MemoryManager(map);

map.on('load', () => {
  buildingManager.add3DBuildings();
  perfMonitor.start();
  
  setInterval(() => {
    memoryManager.checkMemory();
  }, 5000);
});

map.on('zoomend', () => {
  buildingManager.updateVisibleBuildings();
});
```

**Performance Tips:**
```javascript
// âŒ Yomon
map.addLayer({
  type: 'fill-extrusion',
  paint: {
    'fill-extrusion-height': ['get', 'height'], // Har bir building
    'fill-extrusion-color': ['get', 'color']    // Individual colors
  }
});

// âœ… Yaxshi
map.addLayer({
  type: 'fill-extrusion',
  paint: {
    // Grouped colors (kamroq draw calls)
    'fill-extrusion-color': [
      'step',
      ['get', 'height'],
      '#ddd', 10,
      '#bbb', 20,
      '#999', 50,
      '#777'
    ],
    // Simplified heights
    'fill-extrusion-height': [
      'interpolate', ['linear'], ['zoom'],
      15, ['*', ['get', 'height'], 0.5],
      16, ['get', 'height']
    ]
  }
});
```

---

**4. Map'ga real-time WebSocket layer qo'shish arxitekturasi**

```javascript
// 1. WebSocket Manager
class WebSocketMapManager {
  constructor(mapInstance) {
    this.map = mapInstance;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1000;
    
    // Data buffers
    this.updateBuffer = [];
    this.bufferFlushInterval = 100; // ms
    
    // State management
    this.entities = new Map();
    
    this.init();
  }
  
  init() {
    this.connect();
    this.setupMapSource();
    this.startBufferFlusher();
  }
  
  connect() {
    this.ws = new WebSocket('wss://api.example.com/realtime');
    
    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
      this.subscribe(['vehicles', 'incidents', 'traffic']);
    };
    
    this.ws.onmessage = (event) => {
      this.handleMessage(JSON.parse(event.data));
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    this.ws.onclose = () => {
      console.log('WebSocket closed');
      this.reconnect();
    };
  }
  
  reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }
    
    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
    
    console.log(`Reconnecting in ${delay}ms...`);
    
    setTimeout(() => {
      this.connect();
    }, delay);
  }
  
  subscribe(channels) {
    this.ws.send(JSON.stringify({
      type: 'subscribe',
      channels: channels
    }));
  }
  
  handleMessage(message) {
    switch (message.type) {
      case 'update':
        this.bufferUpdate(message.data);
        break;
      case 'delete':
        this.handleDelete(message.data);
        break;
      case 'bulk':
        this.handleBulkUpdate(message.data);
        break;
    }
  }
  
  // Buffering for performance
  bufferUpdate(data) {
    this.updateBuffer.push(data);
  }
  
  startBufferFlusher() {
    setInterval(() => {
      if (this.updateBuffer.length === 0) return;
      
      this.flushBuffer();
    }, this.bufferFlushInterval);
  }
  
  flushBuffer() {
    const updates = this.updateBuffer.splice(0);
    
    // Group by entity type
    const grouped = updates.reduce((acc, update) => {
      const type = update.entityType;
      if (!acc[type]) acc[type] = [];
      acc[type].push(update);
      return acc;
    }, {});
    
    // Update each layer
    Object.entries(grouped).forEach(([type, items]) => {
      this.updateLayer(type, items);
    });
  }
  
  setupMapSource() {
    // Vehicles layer
    this.map.addSource('realtime-vehicles', {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: []
      }
    });
    
    this.map.addLayer({
      id: 'vehicles',
      type: 'symbol',
      source: 'realtime-vehicles',
      layout: {
        'icon-image': 'car-icon',
        'icon-size': 0.5,
        'icon-rotate': ['get', 'bearing'],
        'icon-rotation-alignment': 'map',
        'icon-allow-overlap': true
      }
    });
    
    // Traffic layer
    this.map.addSource('realtime-traffic', {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: []
      }
    });
    
    this.map.addLayer({
      id: 'traffic',
      type: 'line',
      source: 'realtime-traffic',
      paint: {
        'line-color': ['get', 'congestionColor'],
        'line-width': 4,
        'line-opacity': 0.8
      }
    });
  }
  
  updateLayer(layerType, updates) {
    // Update internal state
    updates.forEach(update => {
      this.entities.set(update.id, update);
    });
    
    // Convert to GeoJSON
    const features = Array.from(this.entities.values())
      .filter(e => e.entityType === layerType)
      .map(e => this.toGeoJSONFeature(e));
    
    // Update map
    const sourceName = `realtime-${layerType}`;
    this.map.getSource(sourceName).setData({
      type: 'FeatureCollection',
      features: features
    });
  }
  
  toGeoJSONFeature(entity) {
    return {
      type: 'Feature',
      id: entity.id,
      geometry: {
        type: 'Point',
        coordinates: [entity.lng, entity.lat]
      },
      properties: {
        bearing: entity.bearing || 0,
        speed: entity.speed || 0,
        status: entity.status || 'active'
      }
    };
  }
  
  handleDelete(data) {
    this.entities.delete(data.id);
    this.updateLayer(data.entityType, []);
  }
  
  handleBulkUpdate(data) {
    // Bulk update for initial load
    data.forEach(item => {
      this.entities.set(item.id, item);
    });
    
    // Group and update
    const grouped = {};
    data.forEach(item => {
      if (!grouped[item.entityType]) {
        grouped[item.entityType] = [];
      }
      grouped[item.entityType].push(item);
    });
    
    Object.entries(grouped).forEach(([type, items]) => {
      this.updateLayer(type, items);
    });
  }
  
  // Animation support
  animateMovement(entityId, from, to, duration = 1000) {
    const entity = this.entities.get(entityId);
    if (!entity) return;
    
    const startTime = performance.now();
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Linear interpolation
      const lat = from.lat + (to.lat - from.lat) * progress;
      const lng = from.lng + (to.lng - from.lng) * progress;
      
      // Update entity
      entity.lat = lat;
      entity.lng = lng;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        // Final update
        this.updateLayer(entity.entityType, [entity]);
      }
    };
    
    requestAnimationFrame(animate);
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close();
    }
  }
}

// 2. Usage
const wsManager = new WebSocketMapManager(map);

// 3. Advanced: Delta Updates
class DeltaWebSocketManager extends WebSocketMapManager {
  handleMessage(message) {
    if (message.type === 'delta') {
      this.applyDelta(message.data);
    } else {
      super.handleMessage(message);
    }
  }
  
  applyDelta(delta) {
    const entity = this.entities.get(delta.id);
    if (!entity) return;
    
    // Apply only changed fields
    Object.assign(entity, delta.changes);
    
    this.updateLayer(entity.entityType, [entity]);
  }
}

// 4. Server-side example (Node.js)
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

const clients = new Set();
const vehiclePositions = new Map();

wss.on('connection', (ws) => {
  clients.add(ws);
  
  // Send initial data
  ws.send(JSON.stringify({
    type: 'bulk',
    data: Array.from(vehiclePositions.values())
  }));
  
  ws.on('message', (message) => {
    const data = JSON.parse(message);
    
    if (data.type === 'subscribe') {
      // Handle subscription
    }
  });
  
  ws.on('close', () => {
    clients.delete(ws);
  });
});

// Broadcast updates
function broadcastUpdate(update) {
  const message = JSON.stringify({
    type: 'update',
    data: update
  });
  
  clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}

// Simulate vehicle updates
setInterval(() => {
  vehiclePositions.forEach((vehicle, id) => {
    // Update position
    vehicle.lat += (Math.random() - 0.5) * 0.001;
    vehicle.lng += (Math.random() - 0.5) * 0.001;
    
    broadcastUpdate(vehicle);
  });
}, 1000);
```

Davom ettiraman? GeoJSON diff, LocalStorage, IndexedDB va Clean Architecture savollariga o'tamiz.
