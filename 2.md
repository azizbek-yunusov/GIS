# ðŸ—ºï¸ Map Technologies - Davomi

## ðŸ“ 1. MAP TEXNOLOGIYALARI - Davomi

**8. GeoJSON Point, LineString, Polygon strukturalari**

**Point (Nuqta):**
```javascript
{
  "type": "Feature",
  "geometry": {
    "type": "Point",
    "coordinates": [69.2401, 41.2995] // [longitude, latitude]
  },
  "properties": {
    "name": "Tashkent",
    "population": 2500000,
    "type": "city"
  }
}
```

**LineString (Chiziq):**
```javascript
{
  "type": "Feature",
  "geometry": {
    "type": "LineString",
    "coordinates": [
      [69.2401, 41.2995], // Tashkent
      [69.5964, 40.8378], // Samarkand
      [66.9597, 39.6542]  // Bukhara
    ]
  },
  "properties": {
    "name": "M39 Highway",
    "distance": 550,
    "type": "highway"
  }
}
```

**Polygon (Ko'pburchak):**
```javascript
{
  "type": "Feature",
  "geometry": {
    "type": "Polygon",
    "coordinates": [
      // Outer ring (tashqi chegara)
      [
        [69.1, 41.2],
        [69.3, 41.2],
        [69.3, 41.4],
        [69.1, 41.4],
        [69.1, 41.2] // Oxirgi nuqta = birinchi nuqta
      ],
      // Inner ring (teshik) - optional
      [
        [69.15, 41.25],
        [69.25, 41.25],
        [69.25, 41.35],
        [69.15, 41.35],
        [69.15, 41.25]
      ]
    ]
  },
  "properties": {
    "name": "Tashkent District",
    "area": 334.8
  }
}
```

**MultiPoint, MultiLineString, MultiPolygon:**
```javascript
// MultiPolygon (ko'p polygonlar)
{
  "type": "Feature",
  "geometry": {
    "type": "MultiPolygon",
    "coordinates": [
      [
        [[69.1, 41.2], [69.3, 41.2], [69.3, 41.4], [69.1, 41.2]]
      ],
      [
        [[69.5, 41.5], [69.7, 41.5], [69.7, 41.7], [69.5, 41.5]]
      ]
    ]
  },
  "properties": {
    "name": "Uzbekistan Provinces"
  }
}
```

**FeatureCollection:**
```javascript
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "geometry": { "type": "Point", "coordinates": [69.24, 41.29] },
      "properties": { "city": "Tashkent" }
    },
    {
      "type": "Feature",
      "geometry": { "type": "Point", "coordinates": [69.59, 40.83] },
      "properties": { "city": "Samarkand" }
    }
  ]
}
```

---

**9. Choropleth xaritalar qanday yaratiladi?**

Choropleth - bu polygonlarni qiymat bo'yicha rangga bo'yash (masalan, populyatsiya, daromad).

**Leaflet bilan:**
```javascript
// 1. Data tayyorlash
const provinceData = {
  'Tashkent': { population: 2500000, density: 750 },
  'Samarkand': { population: 550000, density: 190 },
  'Bukhara': { population: 280000, density: 70 }
};

// 2. Rang funksiyasi
function getColor(density) {
  return density > 500 ? '#800026' :
         density > 300 ? '#BD0026' :
         density > 200 ? '#E31A1C' :
         density > 100 ? '#FC4E2A' :
         density > 50  ? '#FD8D3C' :
         density > 20  ? '#FEB24C' :
         density > 10  ? '#FED976' :
                         '#FFEDA0';
}

// 3. Style funksiyasi
function style(feature) {
  const provinceName = feature.properties.name;
  const density = provinceData[provinceName]?.density || 0;
  
  return {
    fillColor: getColor(density),
    weight: 2,
    opacity: 1,
    color: 'white',
    dashArray: '3',
    fillOpacity: 0.7
  };
}

// 4. GeoJSON layer
L.geoJSON(provincesGeoJSON, {
  style: style,
  onEachFeature: (feature, layer) => {
    const name = feature.properties.name;
    const data = provinceData[name];
    
    layer.bindPopup(`
      <strong>${name}</strong><br>
      Population: ${data.population.toLocaleString()}<br>
      Density: ${data.density} per kmÂ²
    `);
    
    // Hover effect
    layer.on({
      mouseover: (e) => {
        e.target.setStyle({
          weight: 5,
          color: '#666',
          fillOpacity: 0.9
        });
      },
      mouseout: (e) => {
        e.target.setStyle(style(feature));
      }
    });
  }
}).addTo(map);

// 5. Legend qo'shish
const legend = L.control({ position: 'bottomright' });

legend.onAdd = function() {
  const div = L.DomUtil.create('div', 'info legend');
  const grades = [0, 10, 20, 50, 100, 200, 300, 500];
  
  div.innerHTML = '<h4>Population Density</h4>';
  
  for (let i = 0; i < grades.length; i++) {
    div.innerHTML +=
      `<i style="background:${getColor(grades[i] + 1)}"></i> ` +
      grades[i] + (grades[i + 1] ? `&ndash;${grades[i + 1]}<br>` : '+');
  }
  
  return div;
};

legend.addTo(map);
```

**Mapbox bilan (data-driven styling):**
```javascript
map.addLayer({
  id: 'choropleth',
  type: 'fill',
  source: 'provinces',
  paint: {
    'fill-color': [
      'interpolate',
      ['linear'],
      ['get', 'density'],
      0, '#FFEDA0',
      10, '#FED976',
      20, '#FEB24C',
      50, '#FD8D3C',
      100, '#FC4E2A',
      200, '#E31A1C',
      300, '#BD0026',
      500, '#800026'
    ],
    'fill-opacity': 0.7
  }
});

// Hover effect
let hoveredStateId = null;

map.on('mousemove', 'choropleth', (e) => {
  if (e.features.length > 0) {
    if (hoveredStateId !== null) {
      map.setFeatureState(
        { source: 'provinces', id: hoveredStateId },
        { hover: false }
      );
    }
    hoveredStateId = e.features[0].id;
    map.setFeatureState(
      { source: 'provinces', id: hoveredStateId },
      { hover: true }
    );
  }
});

// Hover style
'fill-opacity': [
  'case',
  ['boolean', ['feature-state', 'hover'], false],
  0.9,
  0.7
]
```

---

**10. Mapbox'da setData ko'p chaqirilsa nega ishlash sekinlashadi?**

**Muammo:**
```javascript
// âŒ Yomon: Har sekundda butun datani yangilash
setInterval(() => {
  map.getSource('vehicles').setData(allVehiclesGeoJSON);
}, 1000);
```

**Nima sodir bo'ladi:**
1. **Parsing overhead** - Har safar butun GeoJSON parse qilinadi
2. **Rendering** - Butun layer qayta chiziladi
3. **Memory allocation** - Yangi obyektlar yaratiladi
4. **GPU upload** - Data GPU'ga qayta yuklanadi
5. **Garbage collection** - Eski obyektlar tozalanadi

**Yechimlar:**

```javascript
// âœ… Yaxshi 1: Faqat o'zgargan datani yuborish
const previousData = new Map();

function updateVehicles(newVehicles) {
  const updated = newVehicles.filter(vehicle => {
    const prev = previousData.get(vehicle.id);
    if (!prev) return true;
    
    return prev.lat !== vehicle.lat || 
           prev.lng !== vehicle.lng ||
           prev.status !== vehicle.status;
  });
  
  if (updated.length === 0) return;
  
  // Faqat o'zgarganlarni yangilash
  const features = updated.map(v => ({
    type: 'Feature',
    id: v.id,
    geometry: {
      type: 'Point',
      coordinates: [v.lng, v.lat]
    },
    properties: { status: v.status }
  }));
  
  map.getSource('vehicles').setData({
    type: 'FeatureCollection',
    features: features
  });
  
  // Cache'ni yangilash
  updated.forEach(v => previousData.set(v.id, v));
}

// âœ… Yaxshi 2: Debouncing
let updateTimeout;
function scheduleUpdate(data) {
  clearTimeout(updateTimeout);
  updateTimeout = setTimeout(() => {
    map.getSource('vehicles').setData(data);
  }, 100);
}

// âœ… Yaxshi 3: RequestAnimationFrame
let pending = false;
let latestData = null;

function updateData(data) {
  latestData = data;
  
  if (!pending) {
    pending = true;
    requestAnimationFrame(() => {
      map.getSource('vehicles').setData(latestData);
      pending = false;
    });
  }
}

// âœ… Yaxshi 4: Feature state (animatsiya uchun)
// setData o'rniga feature-state ishlatish
map.setFeatureState(
  { source: 'vehicles', id: vehicleId },
  { position: [newLng, newLat], speed: newSpeed }
);

// âœ… Yaxshi 5: Chunking (katta data uchun)
async function updateLargeDataset(allFeatures) {
  const chunkSize = 1000;
  
  for (let i = 0; i < allFeatures.length; i += chunkSize) {
    const chunk = allFeatures.slice(i, i + chunkSize);
    
    map.getSource('data').setData({
      type: 'FeatureCollection',
      features: chunk
    });
    
    // Browser'ga nafas olish imkoniyati
    await new Promise(resolve => setTimeout(resolve, 0));
  }
}

// âœ… Yaxshi 6: Source pooling
const sourcePool = {
  active: 'vehicles-a',
  inactive: 'vehicles-b'
};

function swapUpdate(newData) {
  // Inactive sourceni yangilash
  map.getSource(sourcePool.inactive).setData(newData);
  
  // Layerlarni swap qilish
  map.setLayoutProperty(sourcePool.active, 'visibility', 'none');
  map.setLayoutProperty(sourcePool.inactive, 'visibility', 'visible');
  
  // Pool'ni swap qilish
  [sourcePool.active, sourcePool.inactive] = 
    [sourcePool.inactive, sourcePool.active];
}
```

**Performance monitoring:**
```javascript
let frameCount = 0;
let lastTime = performance.now();

function monitorPerformance() {
  frameCount++;
  const now = performance.now();
  
  if (now - lastTime >= 1000) {
    const fps = Math.round(frameCount * 1000 / (now - lastTime));
    console.log(`FPS: ${fps}`);
    
    if (fps < 30) {
      console.warn('Performance degradation detected!');
    }
    
    frameCount = 0;
    lastTime = now;
  }
  
  requestAnimationFrame(monitorPerformance);
}

monitorPerformance();
```

---

## MURAKKAB SAVOLLAR

**1. 50k markerlarni real vaqtda ko'rsatish kerak. Qanday yondashuv?**

```javascript
// Strategiya: Viewport-based rendering + Clustering + WebGL

class HighPerformanceMarkerSystem {
  constructor(map) {
    this.map = map;
    this.allData = []; // 50k markers
    this.visibleMarkers = new Map();
    this.clusterThreshold = 15; // zoom level
    this.canvas = null;
    
    this.init();
  }
  
  init() {
    // 1. WebGL layer uchun canvas yaratish
    this.canvas = document.createElement('canvas');
    this.gl = this.canvas.getContext('webgl');
    
    // 2. Viewport tracking
    this.map.on('moveend', () => this.updateVisibleMarkers());
    this.map.on('zoomend', () => this.handleZoomChange());
    
    // 3. Initial render
    this.updateVisibleMarkers();
  }
  
  // Spatial indexing (QuadTree)
  buildQuadTree(data) {
    const tree = new QuadTree({
      x: -180,
      y: -90,
      width: 360,
      height: 180
    });
    
    data.forEach(point => {
      tree.insert({
        x: point.lng,
        y: point.lat,
        data: point
      });
    });
    
    return tree;
  }
  
  updateVisibleMarkers() {
    const bounds = this.map.getBounds();
    const zoom = this.map.getZoom();
    
    // QuadTree bilan tez qidirish
    const visible = this.quadTree.query({
      x: bounds.getWest(),
      y: bounds.getSouth(),
      width: bounds.getEast() - bounds.getWest(),
      height: bounds.getNorth() - bounds.getSouth()
    });
    
    if (zoom >= this.clusterThreshold) {
      // Individual markers
      this.renderWebGL(visible);
    } else {
      // Clusters
      this.renderClusters(visible);
    }
  }
  
  // WebGL rendering (juda tez)
  renderWebGL(points) {
    const positions = new Float32Array(points.length * 2);
    const colors = new Float32Array(points.length * 4);
    
    points.forEach((point, i) => {
      const [x, y] = this.latLngToPixel(point.lat, point.lng);
      positions[i * 2] = x;
      positions[i * 2 + 1] = y;
      
      // Color
      colors[i * 4] = point.color.r;
      colors[i * 4 + 1] = point.color.g;
      colors[i * 4 + 2] = point.color.b;
      colors[i * 4 + 3] = 1.0;
    });
    
    // WebGL draw call
    this.drawPoints(positions, colors);
  }
  
  // Clustering algorithm
  renderClusters(points) {
    const gridSize = 60; // px
    const clusters = new Map();
    
    points.forEach(point => {
      const pixel = this.map.project([point.lat, point.lng]);
      const gridX = Math.floor(pixel.x / gridSize);
      const gridY = Math.floor(pixel.y / gridSize);
      const key = `${gridX},${gridY}`;
      
      if (!clusters.has(key)) {
        clusters.set(key, {
          points: [],
          center: pixel,
          count: 0
        });
      }
      
      const cluster = clusters.get(key);
      cluster.points.push(point);
      cluster.count++;
    });
    
    // Clustersni chizish
    this.drawClusters(Array.from(clusters.values()));
  }
  
  // Level of Detail (LOD)
  getPointSize(zoom) {
    if (zoom < 10) return 2;
    if (zoom < 15) return 4;
    return 8;
  }
}

// Ishlatish
const markerSystem = new HighPerformanceMarkerSystem(map);

// Real-time update
webSocket.on('positions', (updates) => {
  // Batch update
  markerSystem.batchUpdate(updates);
});
```

**Keyingi javoblarni davom ettirayinmi?** Point-in-polygon, 3D buildings, WebSocket architecture va boshqa murakkab mavzular qoldi.
