# ðŸ—ºï¸ IndexedDB Transactions va Clean Architecture

## ðŸ“ 5. LocalStorage, IndexedDB va Caching - Davomi

### Murakkab Savollar

**1. Tile caching arxitekturasini tushuntiring**

```javascript
// Tile Caching System Architecture

class TileCachingSystem {
  constructor() {
    this.memoryCache = new Map(); // L1 Cache (RAM)
    this.indexedDB = null;         // L2 Cache (Disk)
    this.maxMemoryCacheSize = 100; // tiles
    this.tileQueue = [];
    this.downloading = new Set();
    
    this.init();
  }
  
  async init() {
    await this.initIndexedDB();
    await this.loadFrequentTilesIntoMemory();
  }
  
  async initIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('TileCacheDB', 1);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        if (!db.objectStoreNames.contains('tiles')) {
          const store = db.createObjectStore('tiles', { keyPath: 'key' });
          
          // Indexes
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('accessCount', 'accessCount', { unique: false });
          store.createIndex('zoomLevel', 'zoomLevel', { unique: false });
        }
      };
      
      request.onsuccess = () => {
        this.indexedDB = request.result;
        resolve();
      };
      
      request.onerror = () => reject(request.error);
    });
  }
  
  // Tile key generator
  getTileKey(z, x, y) {
    return `${z}/${x}/${y}`;
  }
  
  // 3-level caching strategy
  async getTile(z, x, y) {
    const key = this.getTileKey(z, x, y);
    
    // Level 1: Memory cache (fastest)
    if (this.memoryCache.has(key)) {
      console.log('âœ… L1 Cache HIT:', key);
      return this.memoryCache.get(key);
    }
    
    // Level 2: IndexedDB (fast)
    const diskCached = await this.getTileFromDisk(key);
    if (diskCached) {
      console.log('âœ… L2 Cache HIT:', key);
      this.addToMemoryCache(key, diskCached);
      return diskCached;
    }
    
    // Level 3: Network (slow)
    console.log('âŒ Cache MISS:', key);
    return await this.downloadTile(z, x, y);
  }
  
  // Memory cache (LRU eviction)
  addToMemoryCache(key, tile) {
    // LRU: Agar to'lgan bo'lsa eng eski'ni o'chirish
    if (this.memoryCache.size >= this.maxMemoryCacheSize) {
      const firstKey = this.memoryCache.keys().next().value;
      this.memoryCache.delete(firstKey);
    }
    
    this.memoryCache.set(key, tile);
  }
  
  // IndexedDB operations
  async getTileFromDisk(key) {
    return new Promise((resolve, reject) => {
      const transaction = this.indexedDB.transaction(['tiles'], 'readonly');
      const store = transaction.objectStore('tiles');
      const request = store.get(key);
      
      request.onsuccess = () => {
        const result = request.result;
        
        if (result) {
          // Access count yangilash
          this.incrementAccessCount(key);
          resolve(result.data);
        } else {
          resolve(null);
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }
  
  async saveTileToDisk(key, data, z) {
    return new Promise((resolve, reject) => {
      const transaction = this.indexedDB.transaction(['tiles'], 'readwrite');
      const store = transaction.objectStore('tiles');
      
      const tile = {
        key: key,
        data: data,
        timestamp: Date.now(),
        accessCount: 1,
        zoomLevel: z,
        size: data.byteLength || data.length
      };
      
      const request = store.put(tile);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async incrementAccessCount(key) {
    const transaction = this.indexedDB.transaction(['tiles'], 'readwrite');
    const store = transaction.objectStore('tiles');
    
    const getRequest = store.get(key);
    
    getRequest.onsuccess = () => {
      const tile = getRequest.result;
      if (tile) {
        tile.accessCount++;
        tile.lastAccess = Date.now();
        store.put(tile);
      }
    };
  }
  
  // Download tile from network
  async downloadTile(z, x, y) {
    const key = this.getTileKey(z, x, y);
    
    // Agar allaqachon yuklanayotgan bo'lsa - kutish
    if (this.downloading.has(key)) {
      return this.waitForDownload(key);
    }
    
    this.downloading.add(key);
    
    try {
      const url = `https://api.mapbox.com/v4/mapbox.streets/${z}/${x}/${y}.png?access_token=YOUR_TOKEN`;
      
      const response = await fetch(url);
      const blob = await response.blob();
      const arrayBuffer = await blob.arrayBuffer();
      
      // Cache'lash
      await this.saveTileToDisk(key, arrayBuffer, z);
      this.addToMemoryCache(key, arrayBuffer);
      
      this.downloading.delete(key);
      
      return arrayBuffer;
    } catch (error) {
      this.downloading.delete(key);
      throw error;
    }
  }
  
  async waitForDownload(key) {
    return new Promise((resolve) => {
      const checkInterval = setInterval(async () => {
        if (!this.downloading.has(key)) {
          clearInterval(checkInterval);
          const tile = await this.getTileFromDisk(key);
          resolve(tile);
        }
      }, 100);
    });
  }
  
  // Preload tiles (viewport + adjacent)
  async preloadTiles(centerZ, centerX, centerY, radius = 1) {
    const tiles = [];
    
    for (let dz = -1; dz <= 1; dz++) {
      const z = centerZ + dz;
      if (z < 0 || z > 18) continue;
      
      const scale = Math.pow(2, dz);
      
      for (let dx = -radius * scale; dx <= radius * scale; dx++) {
        for (let dy = -radius * scale; dy <= radius * scale; dy++) {
          const x = centerX * scale + dx;
          const y = centerY * scale + dy;
          
          tiles.push({ z, x, y });
        }
      }
    }
    
    // Priority queue (center tiles first)
    tiles.sort((a, b) => {
      const distA = Math.abs(a.x - centerX) + Math.abs(a.y - centerY);
      const distB = Math.abs(b.x - centerX) + Math.abs(b.y - centerY);
      return distA - distB;
    });
    
    // Batch download
    for (const tile of tiles) {
      const key = this.getTileKey(tile.z, tile.x, tile.y);
      
      if (!this.memoryCache.has(key)) {
        const cached = await this.getTileFromDisk(key);
        if (!cached) {
          this.tileQueue.push(tile);
        }
      }
    }
    
    this.processTileQueue();
  }
  
  async processTileQueue() {
    const concurrency = 6; // Max parallel downloads
    const promises = [];
    
    while (this.tileQueue.length > 0 && promises.length < concurrency) {
      const tile = this.tileQueue.shift();
      promises.push(this.downloadTile(tile.z, tile.x, tile.y));
    }
    
    await Promise.all(promises);
    
    // Agar hali queue bo'sh bo'lmasa, davom ettirish
    if (this.tileQueue.length > 0) {
      this.processTileQueue();
    }
  }
  
  // Load frequent tiles into memory
  async loadFrequentTilesIntoMemory() {
    const transaction = this.indexedDB.transaction(['tiles'], 'readonly');
    const store = transaction.objectStore('tiles');
    const index = store.index('accessCount');
    
    // Eng ko'p ishlatiladigan tile'larni olish
    const request = index.openCursor(null, 'prev'); // Descending order
    let count = 0;
    
    request.onsuccess = (event) => {
      const cursor = event.target.result;
      
      if (cursor && count < this.maxMemoryCacheSize) {
        const tile = cursor.value;
        this.memoryCache.set(tile.key, tile.data);
        count++;
        cursor.continue();
      }
    };
  }
  
  // Eviction policy: LRU + Size-based
  async evictOldTiles(maxSizeMB = 100) {
    const transaction = this.indexedDB.transaction(['tiles'], 'readwrite');
    const store = transaction.objectStore('tiles');
    const index = store.index('timestamp');
    
    let totalSize = 0;
    const tiles = [];
    
    // Barcha tile'larni timestamp bo'yicha sorting
    const request = index.openCursor();
    
    request.onsuccess = async (event) => {
      const cursor = event.target.result;
      
      if (cursor) {
        tiles.push(cursor.value);
        totalSize += cursor.value.size;
        cursor.continue();
      } else {
        // Agar limit oshgan bo'lsa, eski'larini o'chirish
        const maxSize = maxSizeMB * 1024 * 1024;
        
        if (totalSize > maxSize) {
          let deletedSize = 0;
          
          for (const tile of tiles) {
            if (totalSize - deletedSize <= maxSize) break;
            
            await store.delete(tile.key);
            deletedSize += tile.size;
            
            // Memory cache'dan ham o'chirish
            this.memoryCache.delete(tile.key);
          }
          
          console.log(`Evicted ${deletedSize / (1024 * 1024)} MB`);
        }
      }
    };
  }
  
  // Statistics
  async getStatistics() {
    const transaction = this.indexedDB.transaction(['tiles'], 'readonly');
    const store = transaction.objectStore('tiles');
    
    return new Promise((resolve) => {
      const request = store.getAll();
      
      request.onsuccess = () => {
        const tiles = request.result;
        
        const stats = {
          totalTiles: tiles.length,
          totalSize: tiles.reduce((sum, t) => sum + t.size, 0),
          memoryCacheSize: this.memoryCache.size,
          averageAccessCount: tiles.reduce((sum, t) => sum + t.accessCount, 0) / tiles.length,
          oldestTile: Math.min(...tiles.map(t => t.timestamp)),
          newestTile: Math.max(...tiles.map(t => t.timestamp))
        };
        
        stats.totalSizeMB = (stats.totalSize / (1024 * 1024)).toFixed(2);
        
        resolve(stats);
      };
    });
  }
}

// Usage with Mapbox/Leaflet
const tileCache = new TileCachingSystem();

map.on('moveend', () => {
  const center = map.getCenter();
  const zoom = Math.floor(map.getZoom());
  
  // Center tile coordinates hisoblash
  const centerTile = latLngToTile(center.lat, center.lng, zoom);
  
  // Preload adjacent tiles
  tileCache.preloadTiles(zoom, centerTile.x, centerTile.y, 2);
});

// Periodic cleanup
setInterval(async () => {
  await tileCache.evictOldTiles(100); // 100 MB limit
}, 5 * 60 * 1000); // Har 5 minutda

// Statistics dashboard
async function showCacheStats() {
  const stats = await tileCache.getStatistics();
  console.log('Cache Statistics:', stats);
}

function latLngToTile(lat, lng, zoom) {
  const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
  const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
  return { x, y };
}
```

---

**2. IndexedDB transaktsiya ishlash tartibi**

```javascript
// IndexedDB Transactions Deep Dive

class TransactionManager {
  constructor(db) {
    this.db = db;
  }
  
  // 1. READONLY transactions (parallel)
  async readParallel() {
    // Bir nechta readonly transactions parallel bajarilishi mumkin
    const promises = [
      this.getUser(1),
      this.getUser(2),
      this.getUser(3)
    ];
    
    return Promise.all(promises);
  }
  
  async getUser(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['users'], 'readonly');
      const store = transaction.objectStore('users');
      const request = store.get(id);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  // 2. READWRITE transactions (serial)
  async writeSerial() {
    // Readwrite transactions ketma-ket bajariladi
    // Bitta vaqtda faqat bitta readwrite transaction
    
    await this.updateUser(1, { name: 'Alice' });
    await this.updateUser(2, { name: 'Bob' });
  }
  
  async updateUser(id, updates) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['users'], 'readwrite');
      const store = transaction.objectStore('users');
      
      const getRequest = store.get(id);
      
      getRequest.onsuccess = () => {
        const user = getRequest.result;
        Object.assign(user, updates);
        
        const putRequest = store.put(user);
        
        putRequest.onsuccess = () => resolve(user);
        putRequest.onerror = () => reject(putRequest.error);
      };
      
      getRequest.onerror = () => reject(getRequest.error);
    });
  }
  
  // 3. Transaction lifecycle
  demonstrateLifecycle() {
    const transaction = this.db.transaction(['users'], 'readwrite');
    
    // Transaction events
    transaction.onabort = () => {
      console.log('Transaction aborted');
    };
    
    transaction.onerror = (event) => {
      console.error('Transaction error:', event.target.error);
    };
    
    transaction.oncomplete = () => {
      console.log('Transaction completed successfully');
    };
    
    const store = transaction.objectStore('users');
    
    // Multiple operations in one transaction
    store.add({ id: 1, name: 'Alice' });
    store.add({ id: 2, name: 'Bob' });
    store.add({ id: 3, name: 'Charlie' });
    
    // Transaction automatically commits when all requests complete
  }
  
  // 4. Manual abort
  async abortTransaction() {
    const transaction = this.db.transaction(['users'], 'readwrite');
    const store = transaction.objectStore('users');
    
    try {
      store.add({ id: 1, name: 'Alice' });
      
      // Condition check
      const count = await this.countUsers();
      if (count > 100) {
        transaction.abort(); // Rollback
        throw new Error('Too many users');
      }
      
      store.add({ id: 2, name: 'Bob' });
      
    } catch (error) {
      console.error('Transaction failed:', error);
    }
  }
  
  // 5. Batch operations (optimized)
  async batchInsert(users) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['users'], 'readwrite');
      const store = transaction.objectStore('users');
      
      let completed = 0;
      const total = users.length;
      
      transaction.oncomplete = () => {
        console.log(`Inserted ${total} users`);
        resolve(total);
      };
      
      transaction.onerror = () => reject(transaction.error);
      
      // Single transaction, multiple operations
      users.forEach(user => {
        const request = store.add(user);
        
        request.onsuccess = () => {
          completed++;
          // Progress reporting
          if (completed % 100 === 0) {
            console.log(`Progress: ${completed}/${total}`);
          }
        };
      });
    });
  }
  
  // 6. Transaction scope (multiple stores)
  async transferBetweenStores() {
    return new Promise((resolve, reject) => {
      // Bir nechta store'lar bilan ishlash
      const transaction = this.db.transaction(
        ['users', 'accounts', 'logs'], 
        'readwrite'
      );
      
      const usersStore = transaction.objectStore('users');
      const accountsStore = transaction.objectStore('accounts');
      const logsStore = transaction.objectStore('logs');
      
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => reject(transaction.error);
      
      // Atomic operation across multiple stores
      const userRequest = usersStore.get(1);
      
      userRequest.onsuccess = () => {
        const user = userRequest.result;
        
        // Update user
        user.balance -= 100;
        usersStore.put(user);
        
        // Update account
        accountsStore.add({
          userId: user.id,
          amount: -100,
          timestamp: Date.now()
        });
        
        // Log
        logsStore.add({
          action: 'transfer',
          userId: user.id,
          timestamp: Date.now()
        });
      };
    });
  }
  
  // 7. Deadlock avoidance
  async avoidDeadlock() {
    // âŒ Yomon: Deadlock mumkin
    // Transaction 1: users -> accounts
    // Transaction 2: accounts -> users
    
    // âœ… Yaxshi: Doim bir xil tartibda
    const transaction = this.db.transaction(
      ['accounts', 'users'], // Alphabetical order
      'readwrite'
    );
  }
  
  // 8. Long-running transactions (chunking)
  async processLargeDataset(data) {
    const chunkSize = 1000;
    
    for (let i = 0; i < data.length; i += chunkSize) {
      const chunk = data.slice(i, i + chunkSize);
      
      await this.batchInsert(chunk);
      
      // Yield to browser
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
}

// Advanced: Transaction Pool
class TransactionPool {
  constructor(db) {
    this.db = db;
    this.queue = [];
    this.active = null;
    this.processing = false;
  }
  
  async execute(stores, mode, operation) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        stores,
        mode,
        operation,
        resolve,
        reject
      });
      
      this.process();
    });
  }
  
  async process() {
    if (this.processing || this.queue.length === 0) return;
    
    this.processing = true;
    const task = this.queue.shift();
    
    try {
      const transaction = this.db.transaction(task.stores, task.mode);
      const result = await task.operation(transaction);
      
      transaction.oncomplete = () => {
        task.resolve(result);
        this.processing = false;
        this.process(); // Process next
      };
      
      transaction.onerror = () => {
        task.reject(transaction.error);
        this.processing = false;
        this.process();
      };
      
    } catch (error) {
      task.reject(error);
      this.processing = false;
      this.process();
    }
  }
}

// Usage
const pool = new TransactionPool(db);

await pool.execute(['users'], 'readwrite', (transaction) => {
  const store = transaction.objectStore('users');
  store.add({ id: 1, name: 'Alice' });
});
```

Davom ettiraman? 100,000 obyektlarni saqlash va Clean Architecture'ga o'tamiz.
