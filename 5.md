# ðŸ—ºï¸ Caching va Clean Architecture

## ðŸ“ 5. LocalStorage, IndexedDB va Caching - Davomi

**3. Service Worker caching strategiyalari**

```javascript
// service-worker.js

const CACHE_VERSION = 'map-cache-v1';
const TILE_CACHE = 'map-tiles-v1';
const API_CACHE = 'api-cache-v1';
const STATIC_CACHE = 'static-v1';

// Cache strategiyalari
const CacheStrategies = {
  // 1. Cache First (offline-first)
  CACHE_FIRST: 'cache-first',
  
  // 2. Network First (real-time data)
  NETWORK_FIRST: 'network-first',
  
  // 3. Stale While Revalidate (tez javob, background yangilanish)
  STALE_WHILE_REVALIDATE: 'stale-while-revalidate',
  
  // 4. Network Only (hech qachon cache'lanmaydigan)
  NETWORK_ONLY: 'network-only',
  
  // 5. Cache Only (offline-only)
  CACHE_ONLY: 'cache-only'
};

// Install event - static assetslarni cache'lash
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE).then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles/main.css',
        '/js/app.js',
        '/js/map-config.js',
        '/icons/marker.png'
      ]);
    })
  );
  
  self.skipWaiting();
});

// Activate event - eski cache'larni tozalash
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => {
            return name !== CACHE_VERSION && 
                   name !== TILE_CACHE && 
                   name !== API_CACHE && 
                   name !== STATIC_CACHE;
          })
          .map((name) => caches.delete(name))
      );
    })
  );
  
  self.clients.claim();
});

// Fetch event - request'larni tutish
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Strategy tanlash
  if (url.pathname.match(/\/tiles\/\d+\/\d+\/\d+/)) {
    // Map tiles - Cache First
    event.respondWith(cacheFirst(request, TILE_CACHE));
  } else if (url.pathname.startsWith('/api/')) {
    // API - Network First
    event.respondWith(networkFirst(request, API_CACHE));
  } else if (url.pathname.match(/\.(png|jpg|svg|css|js)$/)) {
    // Static assets - Stale While Revalidate
    event.respondWith(staleWhileRevalidate(request, STATIC_CACHE));
  } else {
    // Default - Network First
    event.respondWith(networkFirst(request, CACHE_VERSION));
  }
});

// 1. Cache First Strategy
async function cacheFirst(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  
  if (cached) {
    return cached;
  }
  
  try {
    const response = await fetch(request);
    
    // Faqat valid response'larni cache'lash
    if (response.status === 200) {
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    // Offline fallback
    return new Response('Offline', { status: 503 });
  }
}

// 2. Network First Strategy
async function networkFirst(request, cacheName) {
  const cache = await caches.open(cacheName);
  
  try {
    const response = await fetch(request);
    
    // Network'dan kelgan datani cache'lash
    if (response.status === 200) {
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    // Network fail - cache'dan qaytarish
    const cached = await cache.match(request);
    
    if (cached) {
      return cached;
    }
    
    // Fallback response
    return new Response('Network error', { 
      status: 503,
      statusText: 'Service Unavailable'
    });
  }
}

// 3. Stale While Revalidate
async function staleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  
  // Background'da yangilash
  const fetchPromise = fetch(request).then((response) => {
    if (response.status === 200) {
      cache.put(request, response.clone());
    }
    return response;
  });
  
  // Agar cache bo'lsa - darhol qaytarish, background'da yangilash
  return cached || fetchPromise;
}

// 4. Advanced: Tile Cache Management
class TileCacheManager {
  constructor(maxTiles = 1000, maxAge = 7 * 24 * 60 * 60 * 1000) {
    this.maxTiles = maxTiles;
    this.maxAge = maxAge;
  }
  
  async cacheTile(request, response) {
    const cache = await caches.open(TILE_CACHE);
    
    // Metadata saqlash
    const metadata = {
      timestamp: Date.now(),
      url: request.url
    };
    
    // Response bilan metadata'ni birga saqlash
    const blob = await response.blob();
    const headers = new Headers(response.headers);
    headers.set('X-Cache-Timestamp', metadata.timestamp);
    
    const cachedResponse = new Response(blob, {
      status: response.status,
      statusText: response.statusText,
      headers: headers
    });
    
    await cache.put(request, cachedResponse);
    
    // Cache size tekshirish
    await this.enforceLimit();
  }
  
  async enforceLimit() {
    const cache = await caches.open(TILE_CACHE);
    const keys = await cache.keys();
    
    // Agar limit oshgan bo'lsa
    if (keys.length > this.maxTiles) {
      // Eng eski tile'larni o'chirish
      const sorted = await this.sortByAge(keys);
      const toDelete = sorted.slice(0, keys.length - this.maxTiles);
      
      await Promise.all(
        toDelete.map(request => cache.delete(request))
      );
    }
  }
  
  async sortByAge(keys) {
    const cache = await caches.open(TILE_CACHE);
    
    const withTimestamps = await Promise.all(
      keys.map(async (request) => {
        const response = await cache.match(request);
        const timestamp = response.headers.get('X-Cache-Timestamp');
        
        return {
          request: request,
          timestamp: parseInt(timestamp) || 0
        };
      })
    );
    
    return withTimestamps
      .sort((a, b) => a.timestamp - b.timestamp)
      .map(item => item.request);
  }
  
  async clearOldTiles() {
    const cache = await caches.open(TILE_CACHE);
    const keys = await cache.keys();
    const now = Date.now();
    
    const toDelete = [];
    
    for (const request of keys) {
      const response = await cache.match(request);
      const timestamp = parseInt(response.headers.get('X-Cache-Timestamp')) || 0;
      
      if (now - timestamp > this.maxAge) {
        toDelete.push(request);
      }
    }
    
    await Promise.all(
      toDelete.map(request => cache.delete(request))
    );
    
    return toDelete.length;
  }
}

const tileCacheManager = new TileCacheManager();

// Message handler (main thread'dan buyruqlar)
self.addEventListener('message', async (event) => {
  if (event.data.type === 'CLEAR_OLD_TILES') {
    const deleted = await tileCacheManager.clearOldTiles();
    event.ports[0].postMessage({ deleted });
  }
  
  if (event.data.type === 'PRECACHE_AREA') {
    const { bounds, zoomLevels } = event.data;
    await precacheArea(bounds, zoomLevels);
    event.ports[0].postMessage({ success: true });
  }
});

// Precaching function
async function precacheArea(bounds, zoomLevels) {
  const tiles = [];
  
  // Tile coordinates hisoblash
  zoomLevels.forEach(zoom => {
    const minTile = latLngToTile(bounds.north, bounds.west, zoom);
    const maxTile = latLngToTile(bounds.south, bounds.east, zoom);
    
    for (let x = minTile.x; x <= maxTile.x; x++) {
      for (let y = minTile.y; y <= maxTile.y; y++) {
        tiles.push({ x, y, z: zoom });
      }
    }
  });
  
  // Batch download
  const cache = await caches.open(TILE_CACHE);
  
  for (const tile of tiles) {
    const url = `https://api.mapbox.com/v4/mapbox.streets/${tile.z}/${tile.x}/${tile.y}.png?access_token=YOUR_TOKEN`;
    
    try {
      const response = await fetch(url);
      if (response.status === 200) {
        await cache.put(url, response);
      }
    } catch (error) {
      console.error(`Failed to cache tile: ${tile.z}/${tile.x}/${tile.y}`);
    }
  }
}

function latLngToTile(lat, lng, zoom) {
  const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
  const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
  
  return { x, y };
}
```

**Main thread'dan Service Worker'ni ishlatish:**

```javascript
// app.js

class OfflineMapManager {
  constructor() {
    this.serviceWorker = null;
    this.init();
  }
  
  async init() {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/service-worker.js');
        this.serviceWorker = registration.active || registration.installing;
        
        console.log('Service Worker registered');
      } catch (error) {
        console.error('Service Worker registration failed:', error);
      }
    }
  }
  
  // Hududni offline uchun yuklash
  async downloadAreaForOffline(bounds, zoomLevels) {
    if (!this.serviceWorker) {
      throw new Error('Service Worker not available');
    }
    
    // Progress tracking
    const totalTiles = this.calculateTileCount(bounds, zoomLevels);
    let downloaded = 0;
    
    return new Promise((resolve, reject) => {
      const messageChannel = new MessageChannel();
      
      messageChannel.port1.onmessage = (event) => {
        if (event.data.success) {
          resolve();
        } else {
          reject(event.data.error);
        }
      };
      
      this.serviceWorker.postMessage({
        type: 'PRECACHE_AREA',
        bounds: bounds,
        zoomLevels: zoomLevels
      }, [messageChannel.port2]);
    });
  }
  
  calculateTileCount(bounds, zoomLevels) {
    let count = 0;
    
    zoomLevels.forEach(zoom => {
      const minTile = this.latLngToTile(bounds.north, bounds.west, zoom);
      const maxTile = this.latLngToTile(bounds.south, bounds.east, zoom);
      
      count += (maxTile.x - minTile.x + 1) * (maxTile.y - minTile.y + 1);
    });
    
    return count;
  }
  
  latLngToTile(lat, lng, zoom) {
    const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
    
    return { x, y };
  }
  
  // Eski cache'ni tozalash
  async clearOldCache() {
    if (!this.serviceWorker) return;
    
    return new Promise((resolve) => {
      const messageChannel = new MessageChannel();
      
      messageChannel.port1.onmessage = (event) => {
        resolve(event.data.deleted);
      };
      
      this.serviceWorker.postMessage({
        type: 'CLEAR_OLD_TILES'
      }, [messageChannel.port2]);
    });
  }
  
  // Cache size tekshirish
  async getCacheSize() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      
      return {
        usage: estimate.usage,
        quota: estimate.quota,
        usagePercent: (estimate.usage / estimate.quota * 100).toFixed(2)
      };
    }
    
    return null;
  }
}

// Usage
const offlineManager = new OfflineMapManager();

// Toshkent shahrini offline uchun yuklash
document.getElementById('download-offline').addEventListener('click', async () => {
  const bounds = {
    north: 41.4,
    south: 41.2,
    west: 69.1,
    east: 69.4
  };
  
  const zoomLevels = [12, 13, 14, 15];
  
  try {
    await offlineManager.downloadAreaForOffline(bounds, zoomLevels);
    alert('Area downloaded for offline use!');
  } catch (error) {
    alert('Download failed: ' + error.message);
  }
});

// Cache tozalash
document.getElementById('clear-cache').addEventListener('click', async () => {
  const deleted = await offlineManager.clearOldCache();
  alert(`Deleted ${deleted} old tiles`);
});

// Cache size ko'rsatish
async function updateCacheSize() {
  const size = await offlineManager.getCacheSize();
  
  if (size) {
    document.getElementById('cache-size').textContent = 
      `Using ${(size.usage / (1024 * 1024)).toFixed(2)} MB of ${(size.quota / (1024 * 1024)).toFixed(2)} MB (${size.usagePercent}%)`;
  }
}

setInterval(updateCacheSize, 5000);
```

---

**4. Offline map caching (Full example)**

```javascript
// offline-map-controller.js

class OfflineMapController {
  constructor(map) {
    this.map = map;
    this.db = null;
    this.isOffline = !navigator.onLine;
    
    this.init();
  }
  
  async init() {
    // IndexedDB setup
    this.db = await this.openDatabase();
    
    // Network status tracking
    window.addEventListener('online', () => {
      this.isOffline = false;
      this.onNetworkChange(true);
    });
    
    window.addEventListener('offline', () => {
      this.isOffline = true;
      this.onNetworkChange(false);
    });
    
    // Offline mode'da cache'dan yuklash
    if (this.isOffline) {
      await this.loadFromCache();
    }
  }
  
  async openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('OfflineMapDB', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Tiles store
        if (!db.objectStoreNames.contains('tiles')) {
          const tilesStore = db.createObjectStore('tiles', { keyPath: 'key' });
          tilesStore.createIndex('timestamp', 'timestamp');
        }
        
        // Map data store
        if (!db.objectStoreNames.contains('mapData')) {
          db.createObjectStore('mapData', { keyPath: 'id' });
        }
      };
    });
  }
  
  // Offline mode'da map yuklash
  async loadFromCache() {
    console.log('Loading map from cache...');
    
    // GeoJSON data cache'dan yuklash
    const cachedData = await this.getCachedMapData();
    
    if (cachedData) {
      cachedData.forEach(data => {
        if (!this.map.getSource(data.id)) {
          this.map.addSource(data.id, {
            type: 'geojson',
            data: data.geojson
          });
        }
      });
    }
    
    // Offline indicator ko'rsatish
    this.showOfflineIndicator();
  }
  
  // Map data'ni cache'lash
  async cacheMapData(sourceId, geojson) {
    const transaction = this.db.transaction(['mapData'], 'readwrite');
    const store = transaction.objectStore('mapData');
    
    await store.put({
      id: sourceId,
      geojson: geojson,
      timestamp: Date.now()
    });
  }
  
  // Cache'dan olish
  async getCachedMapData() {
    const transaction = this.db.transaction(['mapData'], 'readonly');
    const store = transaction.objectStore('mapData');
    
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  // Network o'zgarganda
  onNetworkChange(isOnline) {
    if (isOnline) {
      this.hideOfflineIndicator();
      this.syncPendingChanges();
    } else {
      this.showOfflineIndicator();
    }
  }
  
  showOfflineIndicator() {
    const indicator = document.createElement('div');
    indicator.id = 'offline-indicator';
    indicator.innerHTML = 'âš ï¸ Offline Mode';
    indicator.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: #ff9800;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 9999;
    `;
    
    document.body.appendChild(indicator);
  }
  
  hideOfflineIndicator() {
    const indicator = document.getElementById('offline-indicator');
    if (indicator) {
      indicator.remove();
    }
  }
  
  // Pending o'zgarishlarni sync qilish
  async syncPendingChanges() {
    // Offline'da qilingan o'zgarishlarni server'ga yuborish
    console.log('Syncing pending changes...');
  }
}

// Usage
const offlineController = new OfflineMapController(map);

// Map source qo'shganda avtomatik cache'lash
map.on('sourcedata', (e) => {
  if (e.isSourceLoaded && e.sourceId) {
    const source = map.getSource(e.sourceId);
    
    if (source.type === 'geojson') {
      offlineController.cacheMapData(e.sourceId, source._data);
    }
  }
});
```

Davom ettiraman? IndexedDB transactions, 100k obyektlar va Clean Architecture'ga o'tamiz.
