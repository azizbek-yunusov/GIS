# ðŸ—ºï¸ Murakkab Savollar va Arxitektura - Davomi

## MURAKKAB SAVOLLAR - Davomi

**5. GeoJSON diff orqali faqat o'zgargan obyektlarni qanday yangilaysiz?**

```javascript
// 1. GeoJSON Diff Engine
class GeoJSONDiffEngine {
  constructor() {
    this.previousState = new Map(); // id -> feature
    this.currentState = new Map();
  }
  
  // Diff hisoblash
  computeDiff(newGeoJSON) {
    const diff = {
      added: [],
      updated: [],
      deleted: [],
      unchanged: []
    };
    
    // Yangi datani Map'ga o'tkazish
    const newFeatures = new Map();
    newGeoJSON.features.forEach(feature => {
      newFeatures.set(feature.id, feature);
    });
    
    // 1. Added va Updated topish
    newFeatures.forEach((newFeature, id) => {
      const oldFeature = this.previousState.get(id);
      
      if (!oldFeature) {
        // Yangi feature
        diff.added.push(newFeature);
      } else if (this.hasChanged(oldFeature, newFeature)) {
        // O'zgargan feature
        diff.updated.push({
          id: id,
          old: oldFeature,
          new: newFeature,
          changes: this.getChanges(oldFeature, newFeature)
        });
      } else {
        diff.unchanged.push(id);
      }
    });
    
    // 2. Deleted topish
    this.previousState.forEach((oldFeature, id) => {
      if (!newFeatures.has(id)) {
        diff.deleted.push(id);
      }
    });
    
    // State yangilash
    this.previousState = newFeatures;
    
    return diff;
  }
  
  // Feature o'zgardimi?
  hasChanged(oldFeature, newFeature) {
    // Geometry o'zgarishi
    const oldCoords = JSON.stringify(oldFeature.geometry.coordinates);
    const newCoords = JSON.stringify(newFeature.geometry.coordinates);
    
    if (oldCoords !== newCoords) return true;
    
    // Properties o'zgarishi
    const oldProps = JSON.stringify(oldFeature.properties);
    const newProps = JSON.stringify(newFeature.properties);
    
    return oldProps !== newProps;
  }
  
  // Qaysi maydonlar o'zgardi?
  getChanges(oldFeature, newFeature) {
    const changes = {
      geometry: false,
      properties: {}
    };
    
    // Geometry check
    const oldCoords = JSON.stringify(oldFeature.geometry.coordinates);
    const newCoords = JSON.stringify(newFeature.geometry.coordinates);
    
    if (oldCoords !== newCoords) {
      changes.geometry = {
        old: oldFeature.geometry.coordinates,
        new: newFeature.geometry.coordinates
      };
    }
    
    // Properties check
    const oldProps = oldFeature.properties;
    const newProps = newFeature.properties;
    
    Object.keys(newProps).forEach(key => {
      if (oldProps[key] !== newProps[key]) {
        changes.properties[key] = {
          old: oldProps[key],
          new: newProps[key]
        };
      }
    });
    
    return changes;
  }
}

// 2. Incremental Map Updater
class IncrementalMapUpdater {
  constructor(map) {
    this.map = map;
    this.diffEngine = new GeoJSONDiffEngine();
    this.sources = new Map();
  }
  
  // Initial load
  initialize(sourceName, geojson) {
    this.sources.set(sourceName, geojson);
    
    if (!this.map.getSource(sourceName)) {
      this.map.addSource(sourceName, {
        type: 'geojson',
        data: geojson
      });
    }
  }
  
  // Incremental update
  update(sourceName, newGeoJSON) {
    const diff = this.diffEngine.computeDiff(newGeoJSON);
    
    console.log('Diff:', {
      added: diff.added.length,
      updated: diff.updated.length,
      deleted: diff.deleted.length,
      unchanged: diff.unchanged.length
    });
    
    // Agar o'zgarishlar kam bo'lsa - incremental update
    if (this.shouldUseIncremental(diff, newGeoJSON)) {
      this.applyIncrementalUpdate(sourceName, diff);
    } else {
      // Ko'p o'zgarish bo'lsa - full update
      this.applyFullUpdate(sourceName, newGeoJSON);
    }
  }
  
  shouldUseIncremental(diff, newGeoJSON) {
    const totalChanges = diff.added.length + diff.updated.length + diff.deleted.length;
    const totalFeatures = newGeoJSON.features.length;
    
    // Agar 20% dan kam o'zgargan bo'lsa - incremental
    return (totalChanges / totalFeatures) < 0.2;
  }
  
  applyIncrementalUpdate(sourceName, diff) {
    const source = this.map.getSource(sourceName);
    const currentData = source._data;
    
    // Remove deleted features
    diff.deleted.forEach(id => {
      const index = currentData.features.findIndex(f => f.id === id);
      if (index !== -1) {
        currentData.features.splice(index, 1);
      }
    });
    
    // Update existing features
    diff.updated.forEach(update => {
      const index = currentData.features.findIndex(f => f.id === update.id);
      if (index !== -1) {
        currentData.features[index] = update.new;
      }
    });
    
    // Add new features
    currentData.features.push(...diff.added);
    
    // Single setData call
    source.setData(currentData);
  }
  
  applyFullUpdate(sourceName, newGeoJSON) {
    this.map.getSource(sourceName).setData(newGeoJSON);
  }
}

// 3. Smart Batching Strategy
class SmartBatchUpdater {
  constructor(map, sourceName) {
    this.map = map;
    this.sourceName = sourceName;
    this.pendingUpdates = [];
    this.batchSize = 100;
    this.batchInterval = 200; // ms
    this.updateTimer = null;
  }
  
  addUpdate(feature, operation) {
    this.pendingUpdates.push({ feature, operation });
    
    // Agar batch to'lgan bo'lsa - darhol flush
    if (this.pendingUpdates.length >= this.batchSize) {
      this.flush();
    } else {
      // Aks holda timer bilan
      this.scheduleFlush();
    }
  }
  
  scheduleFlush() {
    if (this.updateTimer) return;
    
    this.updateTimer = setTimeout(() => {
      this.flush();
    }, this.batchInterval);
  }
  
  flush() {
    if (this.pendingUpdates.length === 0) return;
    
    clearTimeout(this.updateTimer);
    this.updateTimer = null;
    
    const source = this.map.getSource(this.sourceName);
    const currentData = source._data;
    
    // Apply all pending updates
    this.pendingUpdates.forEach(({ feature, operation }) => {
      switch (operation) {
        case 'add':
          currentData.features.push(feature);
          break;
        case 'update':
          const index = currentData.features.findIndex(f => f.id === feature.id);
          if (index !== -1) {
            currentData.features[index] = feature;
          }
          break;
        case 'delete':
          const delIndex = currentData.features.findIndex(f => f.id === feature.id);
          if (delIndex !== -1) {
            currentData.features.splice(delIndex, 1);
          }
          break;
      }
    });
    
    source.setData(currentData);
    this.pendingUpdates = [];
  }
}

// 4. WebSocket bilan integratsiya
class RealtimeDiffUpdater {
  constructor(map, sourceName) {
    this.map = map;
    this.sourceName = sourceName;
    this.batchUpdater = new SmartBatchUpdater(map, sourceName);
    this.ws = null;
  }
  
  connect(url) {
    this.ws = new WebSocket(url);
    
    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleMessage(message);
    };
  }
  
  handleMessage(message) {
    switch (message.type) {
      case 'feature:added':
        this.batchUpdater.addUpdate(message.feature, 'add');
        break;
        
      case 'feature:updated':
        this.batchUpdater.addUpdate(message.feature, 'update');
        break;
        
      case 'feature:deleted':
        this.batchUpdater.addUpdate(
          { id: message.featureId }, 
          'delete'
        );
        break;
        
      case 'bulk:update':
        // Bulk update uchun
        message.features.forEach(f => {
          this.batchUpdater.addUpdate(f, message.operation);
        });
        break;
    }
  }
}

// Usage Example
const updater = new IncrementalMapUpdater(map);

// Initial load
updater.initialize('vehicles', initialGeoJSON);

// Periodic updates
setInterval(async () => {
  const newData = await fetch('/api/vehicles').then(r => r.json());
  updater.update('vehicles', newData);
}, 5000);

// Real-time updates
const realtimeUpdater = new RealtimeDiffUpdater(map, 'live-vehicles');
realtimeUpdater.connect('wss://api.example.com/live');
```

---

## ðŸ“ 5. LocalStorage, IndexedDB va Caching

### Asosiy Savollar

**1. LocalStorage va IndexedDB farqi?**

| Feature | LocalStorage | IndexedDB |
|---------|-------------|-----------|
| **Hajm** | ~5-10MB | ~50MB-1GB+ (browserga bog'liq) |
| **API** | Sinxron | Asinxron |
| **Data type** | Faqat string | Object, Blob, File, ArrayBuffer |
| **Indexing** | Yo'q | Ha, complex queries |
| **Transactions** | Yo'q | Ha, ACID |
| **Performance** | Sekin (blocking) | Tez (non-blocking) |
| **Use case** | Settings, tokens | Large datasets, offline data |

```javascript
// LocalStorage - Simple
localStorage.setItem('user', JSON.stringify({ name: 'John' }));
const user = JSON.parse(localStorage.getItem('user'));

// IndexedDB - Complex
const request = indexedDB.open('MyDatabase', 1);

request.onupgradeneeded = (event) => {
  const db = event.target.result;
  
  // Object store yaratish
  const objectStore = db.createObjectStore('users', { keyPath: 'id' });
  
  // Index yaratish
  objectStore.createIndex('email', 'email', { unique: true });
  objectStore.createIndex('age', 'age', { unique: false });
};

request.onsuccess = (event) => {
  const db = event.target.result;
  
  // Data qo'shish
  const transaction = db.transaction(['users'], 'readwrite');
  const objectStore = transaction.objectStore('users');
  
  objectStore.add({ id: 1, name: 'John', email: 'john@example.com', age: 30 });
  
  // Data o'qish
  const getRequest = objectStore.get(1);
  getRequest.onsuccess = () => {
    console.log(getRequest.result);
  };
};
```

---

**2. IndexedDB'da GeoJSON ni qanday saqlaysiz?**

```javascript
// 1. Database Setup
class GeoJSONIndexedDB {
  constructor(dbName = 'GeoDatabase', version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }
  
  async open() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Features store
        if (!db.objectStoreNames.contains('features')) {
          const featuresStore = db.createObjectStore('features', { 
            keyPath: 'id',
            autoIncrement: true 
          });
          
          // Spatial indexes
          featuresStore.createIndex('type', 'geometry.type', { unique: false });
          featuresStore.createIndex('layer', 'properties.layer', { unique: false });
          
          // Bounding box index (range queries uchun)
          featuresStore.createIndex('bbox', 'bbox', { unique: false });
        }
        
        // Layers store
        if (!db.objectStoreNames.contains('layers')) {
          db.createObjectStore('layers', { keyPath: 'name' });
        }
        
        // Tiles cache store
        if (!db.objectStoreNames.contains('tiles')) {
          const tilesStore = db.createObjectStore('tiles', { keyPath: 'key' });
          tilesStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }
  
  // GeoJSON feature saqlash
  async saveFeature(feature) {
    const transaction = this.db.transaction(['features'], 'readwrite');
    const store = transaction.objectStore('features');
    
    // Bounding box hisoblash (spatial queries uchun)
    const bbox = this.calculateBBox(feature.geometry);
    
    const featureWithBBox = {
      ...feature,
      bbox: bbox,
      timestamp: Date.now()
    };
    
    return new Promise((resolve, reject) => {
      const request = store.put(featureWithBBox);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  // Bulk save (optimized)
  async saveFeatures(features) {
    const transaction = this.db.transaction(['features'], 'readwrite');
    const store = transaction.objectStore('features');
    
    const promises = features.map(feature => {
      const bbox = this.calculateBBox(feature.geometry);
      return new Promise((resolve, reject) => {
        const request = store.put({
          ...feature,
          bbox: bbox,
          timestamp: Date.now()
        });
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    });
    
    return Promise.all(promises);
  }
  
  // Layer bo'yicha olish
  async getFeaturesByLayer(layerName) {
    const transaction = this.db.transaction(['features'], 'readonly');
    const store = transaction.objectStore('features');
    const index = store.index('layer');
    
    return new Promise((resolve, reject) => {
      const request = index.getAll(layerName);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  // Bounding box bo'yicha qidirish
  async getFeaturesInBounds(bounds) {
    const transaction = this.db.transaction(['features'], 'readonly');
    const store = transaction.objectStore('features');
    
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      
      request.onsuccess = () => {
        const features = request.result.filter(feature => {
          return this.bboxIntersects(feature.bbox, bounds);
        });
        resolve(features);
      };
      
      request.onerror = () => reject(request.error);
    });
  }
  
  // GeoJSON FeatureCollection olish
  async getGeoJSON(layerName) {
    const features = await this.getFeaturesByLayer(layerName);
    
    return {
      type: 'FeatureCollection',
      features: features
    };
  }
  
  // Tozalash (eski data)
  async clearOldData(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 days
    const transaction = this.db.transaction(['features'], 'readwrite');
    const store = transaction.objectStore('features');
    const now = Date.now();
    
    return new Promise((resolve, reject) => {
      const request = store.openCursor();
      let deletedCount = 0;
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        
        if (cursor) {
          const feature = cursor.value;
          
          if (now - feature.timestamp > maxAge) {
            cursor.delete();
            deletedCount++;
          }
          
          cursor.continue();
        } else {
          resolve(deletedCount);
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }
  
  // Utility: BBox hisoblash
  calculateBBox(geometry) {
    let coords = [];
    
    if (geometry.type === 'Point') {
      coords = [geometry.coordinates];
    } else if (geometry.type === 'LineString') {
      coords = geometry.coordinates;
    } else if (geometry.type === 'Polygon') {
      coords = geometry.coordinates[0];
    }
    
    const lngs = coords.map(c => c[0]);
    const lats = coords.map(c => c[1]);
    
    return {
      minLng: Math.min(...lngs),
      maxLng: Math.max(...lngs),
      minLat: Math.min(...lats),
      maxLat: Math.max(...lats)
    };
  }
  
  // Utility: BBox intersection
  bboxIntersects(bbox1, bbox2) {
    return !(
      bbox1.maxLng < bbox2.minLng ||
      bbox1.minLng > bbox2.maxLng ||
      bbox1.maxLat < bbox2.minLat ||
      bbox1.minLat > bbox2.maxLat
    );
  }
  
  // Database size
  async getSize() {
    if (navigator.storage && navigator.storage.estimate) {
      const estimate = await navigator.storage.estimate();
      return {
        usage: estimate.usage,
        quota: estimate.quota,
        usageInMB: (estimate.usage / (1024 * 1024)).toFixed(2),
        quotaInMB: (estimate.quota / (1024 * 1024)).toFixed(2)
      };
    }
    return null;
  }
}

// Usage
const geoDB = new GeoJSONIndexedDB();

await geoDB.open();

// Save single feature
await geoDB.saveFeature({
  type: 'Feature',
  id: 1,
  geometry: {
    type: 'Point',
    coordinates: [69.24, 41.29]
  },
  properties: {
    name: 'Tashkent',
    layer: 'cities'
  }
});

// Save multiple features
await geoDB.saveFeatures(allFeatures);

// Get by layer
const cities = await geoDB.getGeoJSON('cities');

// Get in bounds
const visibleFeatures = await geoDB.getFeaturesInBounds({
  minLng: 69.0,
  maxLng: 70.0,
  minLat: 41.0,
  maxLat: 42.0
});

// Clean old data
const deleted = await geoDB.clearOldData();
console.log(`Deleted ${deleted} old features`);

// Check size
const size = await geoDB.getSize();
console.log(`Using ${size.usageInMB} MB of ${size.quotaInMB} MB`);
```

Davom ettiraman? Service Worker caching, offline maps va Clean Architecture'ga o'tamiz.
